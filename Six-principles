总原则：开闭原则（Open Close Principle）
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。
分析：抽象化是开闭原则的关键。
开闭原则还可以通过一个更加具体的"对可变性封装原则"来描述，对可变性封装原则（Principle of Encapsulation of Variation,EVP)要求找到系统的可变因素并将其封装起来。

1、单一职责原则（Single Responsibility Principle,SRP)
	一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。
分析：一个类（或者大到模块，小到方法）承担的职责越多，它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 


2、里氏代换原则(Liskov Substitution Principle, LSP)
两种定义：
①如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。（严格）
②所有引用基类（父类）的地方必须能透明的使用其子类的对象。（相对简单）
分析：里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时在确定其子类类型，用子类对象来替换父类对象。

3、依赖倒转原则（Dependence Inversion Principle，DIP）
	面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
分析：要针对接口编程，不要针对实现编程。
依赖注入 
构造注入(Constructor Injection)：通过构造函数注入实例变量。 
设值注入(Setter Injection)：通过Setter方法注入实例变量。 
接口注入(Interface Injection)：通过接口方法注入实例变量。 

4、接口隔离原则(Interface Segregation Principle, ISP)
	客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
分析：使用接口隔离原则拆分接口是，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。
可以在进行系统设计时采用定制服务的方式，即为不同的客户端提供宽窄不同的接口，只提供用户需要的行为，而隐藏用户不需要的行为。

5、合成复用原则(Composite Reuse Principle, CRP)
	尽量首先使用合成\聚合的方式，而不是使用继承。
继承复用和组合\聚合复用的区别
继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（"白箱"复用）
组合\聚合复用：耦合度相对较低，选择性地调用成员对象地操作；可以在运行时动态进行（"黑箱"复用）

6、迪米特法则（Law of Demeter，LOD）
	又称之为最少知识原则
	（1）不要和"陌生人说话"
	（2）只与你的直接朋友通信。
	（3）每一个软件单位对其他的单位都只有最少的只是，而且局限于那些与本单位密切相关的软件单位。
分析：简单地说，就是值一个软件实体应当尽可能少地与其他实体发生相互作用。
朋友包括：
		（1）当前对象本身（this）；
		（2）以参数形式传入到当前对象方法中的对象；
		（3）当前对象的成员对象；
		（4）如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
		（5）当前对象所创建的对象；
否则就是陌生人
主要用途：控制信息的过载：
	在类的划分上，应当尽量创建松耦合的类。
	在类的结构设计上，每个类都应当及你那个降低其成员变量和成员函数的访问权限；
	在类的设计上，只要有可能，一个类型应当设计成不变类；
	在对其他类的引用上，一个对象对其他对象的引用应当降到最低。